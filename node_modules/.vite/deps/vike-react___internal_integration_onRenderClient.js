import {
  require_react_dom
} from "./chunk-XPR23Y44.js";
import {
  __commonJS,
  __toESM,
  require_react
} from "./chunk-I4MZPW7S.js";

// node_modules/react-dom/client.js
var require_client = __commonJS({
  "node_modules/react-dom/client.js"(exports) {
    "use strict";
    var m = require_react_dom();
    if (false) {
      exports.createRoot = m.createRoot;
      exports.hydrateRoot = m.hydrateRoot;
    } else {
      i = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      exports.createRoot = function(c, o) {
        i.usingClientEntryPoint = true;
        try {
          return m.createRoot(c, o);
        } finally {
          i.usingClientEntryPoint = false;
        }
      };
      exports.hydrateRoot = function(c, h, o) {
        i.usingClientEntryPoint = true;
        try {
          return m.hydrateRoot(c, h, o);
        } finally {
          i.usingClientEntryPoint = false;
        }
      };
    }
    var i;
  }
});

// node_modules/vike-react/dist/integration/onRenderClient.js
var import_client = __toESM(require_client());

// node_modules/vike-react/dist/utils/isCallable.js
function isCallable(thing) {
  return thing instanceof Function || typeof thing === "function";
}

// node_modules/vike-react/dist/hooks/useConfig/configsCumulative.js
var configsCumulative = ["Head", "bodyAttributes", "htmlAttributes"];

// node_modules/vike-react/dist/utils/includes.js
function includes(values, x) {
  return values.includes(x);
}

// node_modules/vike-react/dist/integration/getHeadSetting.js
function getHeadSetting(configName, pageContext) {
  var _a;
  const valFromUseConfig = (_a = pageContext._configFromHook) == null ? void 0 : _a[configName];
  const valFromConfig = pageContext.config[configName];
  const getCallable = (val) => isCallable(val) ? val(pageContext) : val;
  if (!includes(configsCumulative, configName)) {
    if (valFromUseConfig !== void 0)
      return valFromUseConfig;
    return getCallable(valFromConfig);
  } else {
    return [
      //
      ...(valFromConfig ?? []).map(getCallable),
      ...valFromUseConfig ?? []
    ];
  }
}

// node_modules/vike-react/dist/integration/getPageElement.js
var import_react2 = __toESM(require_react(), 1);

// node_modules/vike-react/dist/hooks/usePageContext.js
var import_react = __toESM(require_react(), 1);

// node_modules/vike-react/dist/utils/getGlobalObject.js
function getGlobalObject(key, defaultValue) {
  const globalObjectsAll = globalThis[projectKey] = globalThis[projectKey] || {};
  const globalObject2 = globalObjectsAll[key] = globalObjectsAll[key] || defaultValue;
  return globalObject2;
}
var projectKey = "_vike_react";

// node_modules/vike-react/dist/hooks/usePageContext.js
var globalObject = getGlobalObject("PageContextProvider.ts", {
  reactContext: import_react.default.createContext(void 0)
});
function PageContextProvider({ pageContext, children }) {
  const { reactContext } = globalObject;
  return import_react.default.createElement(reactContext.Provider, { value: pageContext }, children);
}

// node_modules/vike-react/dist/integration/getPageElement.js
function getPageElement(pageContext) {
  const { Page, config: { Loading } } = pageContext;
  let page = Page ? import_react2.default.createElement(Page, null) : null;
  const addSuspense = (el) => {
    if (!(Loading == null ? void 0 : Loading.layout))
      return el;
    return import_react2.default.createElement(import_react2.Suspense, { fallback: import_react2.default.createElement(Loading.layout, null) }, page);
  };
  page = addSuspense(page);
  [
    // Inner wrapping
    ...pageContext.config.Layout || [],
    // Outer wrapping
    ...pageContext.config.Wrapper || []
  ].forEach((Wrap) => {
    page = import_react2.default.createElement(Wrap, null, page);
    page = addSuspense(page);
  });
  page = import_react2.default.createElement(PageContextProvider, { pageContext }, page);
  let renderPromiseResolve;
  let renderPromise = new Promise((r) => renderPromiseResolve = r);
  page = import_react2.default.createElement(RenderPromiseProvider, { renderPromiseResolve }, page);
  if (pageContext.config.reactStrictMode !== false) {
    page = import_react2.default.createElement(import_react2.default.StrictMode, null, page);
  }
  return { page, renderPromise };
}
function RenderPromiseProvider({ children, renderPromiseResolve }) {
  (0, import_react2.useEffect)(renderPromiseResolve);
  return children;
}

// node_modules/vike-react/dist/integration/onRenderClient.js
import "/workspace/vike-app/node_modules/vike-react/dist/integration/styles.css";

// node_modules/vike-react/dist/utils/callCumulativeHooks.js
import { providePageContext } from "vike/getPageContext";
async function callCumulativeHooks(values, pageContext) {
  if (!values)
    return [];
  const valuesPromises = values.map((val) => {
    if (isCallable(val)) {
      providePageContext(pageContext);
      return val(pageContext);
    } else {
      return val;
    }
  });
  const valuesResolved = await Promise.all(valuesPromises);
  return valuesResolved;
}

// node_modules/vike-react/dist/integration/applyHeadSettings.js
function applyHeadSettings(title, lang) {
  if (title !== void 0)
    document.title = title || "";
  if (lang !== void 0)
    document.documentElement.lang = lang || "en";
}

// node_modules/vike-react/dist/utils/objectEntries.js
function objectEntries(obj) {
  return Object.entries(obj);
}

// node_modules/vike-react/dist/integration/resolveReactOptions.js
function resolveReactOptions(pageContext) {
  const optionsAcc = {};
  (pageContext.config.react ?? []).forEach((valUnresolved) => {
    const optionList = isCallable(valUnresolved) ? valUnresolved(pageContext) : valUnresolved;
    if (!optionList)
      return;
    objectEntries(optionList).forEach(([fnName, options]) => {
      if (!options)
        return;
      optionsAcc[fnName] ?? (optionsAcc[fnName] = {});
      objectEntries(options).forEach(([key, val]) => {
        var _a;
        if (!isCallable(val)) {
          (_a = optionsAcc[fnName])[key] ?? (_a[key] = val);
        } else {
          const valPrevious = optionsAcc[fnName][key];
          optionsAcc[fnName][key] = (...args) => {
            valPrevious == null ? void 0 : valPrevious(...args);
            val(...args);
          };
        }
      });
    });
  });
  return optionsAcc;
}

// node_modules/vike-react/dist/integration/onRenderClient.js
var root;
var onRenderClient = async (pageContext) => {
  pageContext._headAlreadySet = pageContext.isHydration;
  await callCumulativeHooks(pageContext.config.onBeforeRenderClient, pageContext);
  const { page, renderPromise } = getPageElement(pageContext);
  pageContext.page = page;
  const onUncaughtError = (_error, _errorInfo) => {
  };
  const container = document.getElementById("root");
  const { hydrateRootOptions, createRootOptions } = resolveReactOptions(pageContext);
  if (pageContext.isHydration && // Whether the page was [Server-Side Rendered](https://vike.dev/ssr).
  container.innerHTML !== "") {
    root = import_client.default.hydrateRoot(container, page, hydrateRootOptions);
  } else {
    if (!root) {
      root = import_client.default.createRoot(container, createRootOptions);
    }
    root.render(page);
  }
  pageContext.root = root;
  await renderPromise;
  if (!pageContext.isHydration) {
    pageContext._headAlreadySet = true;
    applyHead(pageContext);
  }
  await callCumulativeHooks(pageContext.config.onAfterRenderClient, pageContext);
};
function applyHead(pageContext) {
  const title = getHeadSetting("title", pageContext);
  const lang = getHeadSetting("lang", pageContext);
  applyHeadSettings(title, lang);
}
export {
  onRenderClient
};
//# sourceMappingURL=vike-react___internal_integration_onRenderClient.js.map
