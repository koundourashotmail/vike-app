"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderToWebStream_set = exports.renderToNodeStream_set = exports.disable = exports.renderToStream = void 0;
const react_1 = __importDefault(require("react"));
const server_1 = __importStar(require("react-dom/server"));
const useSuspenseData_1 = require("./useAsync/useSuspenseData");
const useStream_1 = require("./useStream");
const resolveSeoStrategy_1 = require("./renderToStream/resolveSeoStrategy");
const utils_1 = require("./utils");
const common_1 = require("./renderToStream/common");
const globalObject = (0, utils_1.getGlobalObject)('renderToStream.ts', {
    renderToNodeStream: null,
    renderToWebStream: null,
});
assertReact();
const globalConfig = (globalThis.__react_streaming = globalThis
    .__react_streaming || {
    disable: false,
});
function disable() {
    globalConfig.disable = true;
}
exports.disable = disable;
async function renderToStream(element, options = {}) {
    var _a, _b;
    // Let's see if a user complains
    (0, utils_1.assertUsage)(!options.renderToPipeableStream && !options.renderToReadableStream, 'using deprecated options');
    element = react_1.default.createElement(useSuspenseData_1.SuspenseData, null, element);
    const buffer = [];
    let injectToStream = async (chunk) => {
        buffer.push(chunk);
    };
    const doNotClosePromise = { promise: null };
    let doNotCloseTimeout = null;
    const doNotClose = () => {
        let resolve;
        doNotClosePromise.promise = new Promise((r) => (resolve = r));
        if (doNotCloseTimeout)
            clearTimeout(doNotCloseTimeout);
        doNotCloseTimeout = setTimeout(() => {
            (0, utils_1.assertUsage)(false, 'makeClosableAgain() not called after 10 seconds (`const makeClosableAgain = stream.doNotClose()`)');
        }, 10 * 1000);
        const makeClosableAgain = () => {
            // TODO: add timeout to ensure makeClosableAgain() was called
            resolve();
            clearTimeout(doNotCloseTimeout);
        };
        return makeClosableAgain;
    };
    let abortFn;
    const setAbortFn = (fn) => (abortFn = fn);
    const streamTimeout = (() => {
        var _a;
        // User explicity opting out of timeout (the default value is `undefined` not `null`)
        if (options.timeout === null)
            return null;
        return setTimeout(() => {
            var _a;
            (0, utils_1.assert)(abortFn);
            abortFn();
            (_a = options.onTimeout) === null || _a === void 0 ? void 0 : _a.call(options);
        }, ((_a = options.timeout) !== null && _a !== void 0 ? _a : 20) * 1000);
    })();
    const clearTimeouts = () => {
        if (streamTimeout !== null)
            clearTimeout(streamTimeout);
        if (doNotCloseTimeout !== null)
            clearTimeout(doNotCloseTimeout);
    };
    let hasStreamEnded = () => false;
    element = react_1.default.createElement(useStream_1.StreamProvider, {
        value: {
            injectToStream: (chunk, options) => injectToStream(chunk, options),
            hasStreamEnded: () => hasStreamEnded(),
            doNotClose,
        },
    }, element);
    const disable = globalConfig.disable || ((_a = options.disable) !== null && _a !== void 0 ? _a : (0, resolveSeoStrategy_1.resolveSeoStrategy)(options).disableStream);
    const webStream = (_b = options.webStream) !== null && _b !== void 0 ? _b : !globalObject.renderToNodeStream;
    (0, common_1.debugFlow)(`disable === ${disable} && webStream === ${webStream}`);
    let ret;
    const retCommon = { disabled: disable, doNotClose };
    if (!webStream) {
        ret = Object.assign(Object.assign({}, retCommon), (await globalObject.renderToNodeStream(element, disable, options, doNotClosePromise, setAbortFn, clearTimeouts)));
    }
    else {
        (0, utils_1.assert)(globalObject.renderToWebStream);
        ret = Object.assign(Object.assign({}, retCommon), (await globalObject.renderToWebStream(element, disable, options, doNotClosePromise, setAbortFn, clearTimeouts)));
    }
    injectToStream = ret.injectToStream;
    buffer.forEach((chunk) => injectToStream(chunk));
    buffer.length = 0;
    hasStreamEnded = ret.hasStreamEnded;
    (0, common_1.debugFlow)('promise `await renderToStream()` resolved');
    return ret;
}
exports.renderToStream = renderToStream;
function renderToNodeStream_set(renderToNodeStream) {
    globalObject.renderToNodeStream = renderToNodeStream;
}
exports.renderToNodeStream_set = renderToNodeStream_set;
function renderToWebStream_set(renderToWebStream) {
    globalObject.renderToWebStream = renderToWebStream;
}
exports.renderToWebStream_set = renderToWebStream_set;
// To debug wrong peer dependency loading:
//  - https://stackoverflow.com/questions/21056748/seriously-debugging-node-js-cannot-find-module-xyz-abcd
//  - https://stackoverflow.com/questions/59865584/how-to-invalidate-cached-require-resolve-results
function assertReact() {
    const versionMajor = parseInt(server_1.version.split('.')[0], 10);
    (0, utils_1.assertUsage)(versionMajor >= 18, `\`react-dom@${server_1.version}\` was loaded, but react-streaming only works with React version 18 or greater.`);
    (0, utils_1.assert)(typeof server_1.default.renderToPipeableStream === 'function' ||
        typeof server_1.default.renderToReadableStream === 'function');
}
