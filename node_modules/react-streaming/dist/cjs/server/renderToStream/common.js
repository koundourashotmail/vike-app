"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.wrapStreamEnd = exports.assertReactImport = exports.afterReactBugCatch = exports.debugFlow = void 0;
const utils_1 = require("../utils");
exports.debugFlow = (0, utils_1.createDebugger)('react-streaming:flow');
// Needed for the hacky solution to workaround https://github.com/facebook/react/issues/24536
function afterReactBugCatch(fn) {
    setTimeout(() => {
        fn();
    }, 0);
}
exports.afterReactBugCatch = afterReactBugCatch;
function assertReactImport(fn, fnName) {
    (0, utils_1.assert)(typeof fn === 'function');
    (0, utils_1.assertUsage)(fn, `Couldn't import ${fnName}() from 'react-dom'`);
}
exports.assertReactImport = assertReactImport;
function wrapStreamEnd(streamEnd, didError) {
    return (streamEnd
        // Needed because of the `afterReactBugCatch()` hack above, otherwise `onBoundaryError` triggers after `streamEnd` resolved
        .then(() => new Promise((r) => setTimeout(r, 0)))
        .then(() => !didError));
}
exports.wrapStreamEnd = wrapStreamEnd;
