"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderToNodeStream = void 0;
// @ts-expect-error types export missing
const server_node_1 = require("react-dom/server.node");
const createPipeWrapper_1 = require("./createPipeWrapper");
const common_1 = require("./common");
async function renderToNodeStream(element, disable, options, doNotClosePromise, setAbortFn, clearTimeouts) {
    var _a;
    (0, common_1.debugFlow)('creating Node.js Stream Pipe');
    let onAllReady;
    const allReady = new Promise((r) => {
        onAllReady = () => r();
    });
    let onShellReady;
    const shellReady = new Promise((r) => {
        onShellReady = () => r();
    });
    let didError = false;
    let firstErr = null;
    let reactBug = null;
    const onError = (err) => {
        (0, common_1.debugFlow)('[react] onError() / onShellError()');
        didError = true;
        firstErr !== null && firstErr !== void 0 ? firstErr : (firstErr = err);
        onShellReady();
        (0, common_1.afterReactBugCatch)(() => {
            var _a;
            // Is not a React internal error (i.e. a React bug)
            if (err !== reactBug) {
                (_a = options.onBoundaryError) === null || _a === void 0 ? void 0 : _a.call(options, err);
            }
        });
    };
    const renderToPipeableStream = (_a = options.renderToPipeableStream) !== null && _a !== void 0 ? _a : server_node_1.renderToPipeableStream;
    if (!options.renderToPipeableStream) {
        (0, common_1.assertReactImport)(renderToPipeableStream, 'renderToPipeableStream');
    }
    const { pipe: pipeOriginal, abort } = renderToPipeableStream(element, Object.assign(Object.assign({}, options.streamOptions), { onShellReady() {
            (0, common_1.debugFlow)('[react] onShellReady()');
            onShellReady();
        },
        onAllReady() {
            (0, common_1.debugFlow)('[react] onAllReady()');
            onShellReady();
            onAllReady();
        }, onShellError: onError, onError }));
    setAbortFn(() => {
        abort();
    });
    let promiseResolved = false;
    const onReactBug = (err) => {
        (0, common_1.debugFlow)('react bug');
        didError = true;
        firstErr !== null && firstErr !== void 0 ? firstErr : (firstErr = err);
        reactBug = err;
        // Only log if it wasn't used as rejection for `await renderToStream()`
        if (reactBug !== firstErr || promiseResolved) {
            console.error(reactBug);
        }
    };
    const { pipeForUser, injectToStream, streamEnd, hasStreamEnded } = await (0, createPipeWrapper_1.createPipeWrapper)(pipeOriginal, onReactBug, clearTimeouts, doNotClosePromise);
    await shellReady;
    if (didError)
        throw firstErr;
    if (disable)
        await allReady;
    if (didError)
        throw firstErr;
    promiseResolved = true;
    return {
        pipe: pipeForUser,
        abort,
        readable: null,
        streamEnd: (0, common_1.wrapStreamEnd)(streamEnd, didError),
        injectToStream,
        hasStreamEnded,
    };
}
exports.renderToNodeStream = renderToNodeStream;
