"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderToWebStream = void 0;
const createReadableWrapper_1 = require("./createReadableWrapper");
const common_1 = require("./common");
async function renderToWebStream(element, disable, options, doNotClosePromise, setAbortFn, clearTimeouts) {
    var _a;
    (0, common_1.debugFlow)('creating Web Stream Pipe');
    // We import 'react-dom/server.browser' only if needed, because merely importing it prevents Node.js from exiting (e.g. after running Vike's prerender() API).
    // - Reproduction: https://github.com/vikejs/vike/blob/a0d6777c84aee4c2e5bd0a0a585b18f7a87c8cac/test/playground/scripts/prerender.js
    // @ts-expect-error types export missing
    const { renderToReadableStream: renderToReadableStream_ } = await import('react-dom/server.browser');
    const controller = new AbortController();
    setAbortFn(() => {
        controller.abort();
    });
    let didError = false;
    let firstErr = null;
    let reactBug = null;
    const onError = (err) => {
        didError = true;
        firstErr = firstErr || err;
        (0, common_1.afterReactBugCatch)(() => {
            var _a;
            // Is not a React internal error (i.e. a React bug)
            if (err !== reactBug) {
                (_a = options.onBoundaryError) === null || _a === void 0 ? void 0 : _a.call(options, err);
            }
        });
    };
    const renderToReadableStream = (_a = options.renderToReadableStream) !== null && _a !== void 0 ? _a : renderToReadableStream_;
    if (!options.renderToReadableStream) {
        (0, common_1.assertReactImport)(renderToReadableStream, 'renderToReadableStream');
    }
    const readableOriginal = await renderToReadableStream(element, Object.assign({ onError, signal: controller.signal }, options.streamOptions));
    const { allReady } = readableOriginal;
    let promiseResolved = false;
    // Upon React internal errors (i.e. React bugs), React rejects `allReady`.
    // React doesn't reject `allReady` upon boundary errors.
    allReady.catch((err) => {
        (0, common_1.debugFlow)('react bug');
        didError = true;
        firstErr = firstErr || err;
        reactBug = err;
        // Only log if it wasn't used as rejection for `await renderToStream()`
        if (reactBug !== firstErr || promiseResolved) {
            console.error(reactBug);
        }
    });
    if (didError)
        throw firstErr;
    if (disable)
        await allReady;
    if (didError)
        throw firstErr;
    const { readableForUser, streamEnd, injectToStream, hasStreamEnded } = (0, createReadableWrapper_1.createReadableWrapper)(readableOriginal, clearTimeouts, doNotClosePromise);
    promiseResolved = true;
    return {
        readable: readableForUser,
        pipe: null,
        abort: controller.abort,
        streamEnd: (0, common_1.wrapStreamEnd)(streamEnd, didError),
        injectToStream,
        hasStreamEnded,
    };
}
exports.renderToWebStream = renderToWebStream;
