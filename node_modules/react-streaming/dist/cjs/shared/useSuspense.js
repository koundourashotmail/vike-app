"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useSuspense = void 0;
const utils_1 = require("./utils");
// Workaround for React useId() bug
const globalObject = (0, utils_1.getGlobalObject)('useSuspense.ts', {
    workaroundCache: {},
});
const { workaroundCache } = globalObject;
//*/
const DEBUG = false;
/*/
const DEBUG = true
//*/
function useSuspense({ key, elementId, suspenses, resolver, resolverSync, needsWorkaround, asyncFnName, }) {
    DEBUG && console.log('=== useSuspense()');
    const suspenseId = getSuspenseId(key, elementId);
    DEBUG && console.log('key', key);
    DEBUG && console.log('suspenseId', suspenseId);
    let suspense = suspenses[suspenseId];
    DEBUG && console.log('suspense', suspense);
    // Sync
    if (!suspense && resolverSync) {
        const resolved = resolverSync();
        if (resolved) {
            const { value } = resolved;
            suspense = suspenses[suspenseId] = { state: 'done', value };
            DEBUG && console.log('resolverSync()', suspense);
        }
    }
    // We need to use a cache to workaround [Bug: useId() not working inside <Suspense> #24669](https://github.com/facebook/react/issues/24669)
    if (!suspense && needsWorkaround) {
        const found = workaroundCache[key];
        if (found) {
            suspense = found.suspense;
            DEBUG && console.log('from workaroundCache', suspense);
            if (suspense.state === 'done') {
                suspenses[suspenseId] = suspense; // The `useId()` bug doesn't apply anymore (i.e. `useId()` is stable) after the <Suspense> boundary resolved => we can now use the `suspenses` object as usual
                if (found.cacheTimeout === null) {
                    // We need to allow concurrent <Suspense> boundaries with the same key to piggy back on the resolved value. Otherwise only one boundary gets the value while the others re-trigger the data fetching (i.e. `resolver()` & `asyncFn()`).
                    found.cacheTimeout = setTimeout(() => {
                        found.cacheTimeout = null;
                        delete workaroundCache[key];
                    }, 
                    // Too low => concurrent <Suspense> boundaries with the same key may re-trigger data fetching upon heavy & slow rendering.
                    // Too high => user navigating to another page and quickly going back will see cached data. (But we don't want our low-level `useAsync()` hook to be a cache: it should be higher-level wrapper hooks such as React Query that implement caching.)
                    1000);
                }
            }
        }
    }
    // Async
    {
        const updateSuspenseAsync = (s) => {
            suspense = s;
            if (!needsWorkaround) {
                suspenses[suspenseId] = suspense;
                return;
            }
            {
                const found = workaroundCache[key];
                if (found === null || found === void 0 ? void 0 : found.cacheTimeout) {
                    clearTimeout(found.cacheTimeout);
                }
            }
            workaroundCache[key] = {
                suspense,
                cacheTimeout: null,
            };
        };
        if (!suspense) {
            let ret;
            try {
                ret = resolver();
                DEBUG && console.log('resolver()');
                if (!(0, utils_1.isPromise)(ret)) {
                    const fnName = asyncFnName || 'fn';
                    (0, utils_1.assertWarning)(false, `[useAsync(key, ${fnName})] You provided a function \`${fnName}\` which didn't return a promise`, {
                        onlyOnce: true,
                        showStackTrace: true,
                    });
                    suspense = suspenses[suspenseId] = { state: 'done', value: ret };
                }
                else {
                    const promise = ret
                        .then((value) => {
                        updateSuspenseAsync({ state: 'done', value });
                        DEBUG && console.log('=== resolver() done', suspense);
                    })
                        .catch((err) => {
                        updateSuspenseAsync({ state: 'error', err });
                        DEBUG && console.log('=== resolver() error', suspense);
                    });
                    updateSuspenseAsync({ state: 'pending', promise });
                }
            }
            catch (err) {
                updateSuspenseAsync({ state: 'error', err });
            }
            (0, utils_1.assert)(suspense);
        }
    }
    if (suspense.state === 'pending') {
        bugCatcher();
        (0, utils_1.assert)((0, utils_1.isPromise)(suspense.promise));
        throw suspense.promise;
    }
    if (suspense.state === 'error') {
        // Retry next time
        delete suspenses[suspenseId];
        const { err } = suspense;
        // React swallows boundary errors
        console.error(err);
        throw err;
    }
    if (suspense.state === 'done') {
        return suspense.value;
    }
    (0, utils_1.assert)(false);
}
exports.useSuspense = useSuspense;
// Infinite look catcher.
//  - It works like this: throw an error if `bugCatcher()` is called >1000 times within 30 seconds.
var count;
function bugCatcher() {
    if (count === undefined) {
        count = 0;
        setTimeout(() => {
            count = undefined;
        }, 30 * 1000);
    }
    if (++count > 1000) {
        throw new Error('Infinite loop detected. This possibly is a React bug. Reach out to the https://github.com/brillout/react-streaming maintainer.');
    }
}
function getSuspenseId(key, elementId) {
    (0, utils_1.assert)(!elementId.includes('_'));
    return `${key}_${elementId}`;
}
