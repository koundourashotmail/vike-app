"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.getProjectError = exports.assertInfo = exports.assertWarning = exports.assertUsage = exports.assert = void 0;
const createErrorWithCleanStackTrace_1 = require("./createErrorWithCleanStackTrace");
const getGlobalObject_1 = require("./getGlobalObject");
const projectInfo_1 = require("./projectInfo");
const picocolors_1 = __importDefault(require("@brillout/picocolors"));
const errorPrefix = `[${projectInfo_1.projectInfo.npmPackageName}@${projectInfo_1.projectInfo.projectVersion}]`;
const internalErrorPrefix = `${errorPrefix}[Bug]`;
const usageErrorPrefix = `${errorPrefix}[Wrong Usage]`;
const warningPrefix = `${errorPrefix}[Warning]`;
const infoPrefix = `${errorPrefix}[Info]`;
const numberOfStackTraceLinesToRemove = 2;
const globalObject = (0, getGlobalObject_1.getGlobalObject)('assert.ts', {
    versions: new Set(),
    alreadyLogged: new Set(),
});
const { versions } = globalObject;
const alreadyLogged = (_a = globalObject.alreadyLogged) !== null && _a !== void 0 ? _a : 
// TODO/eventually: remove
// We need to set the same default again because older react-streaming versions (published before 11.03.2025) don't set any default in their getGlobalObject() call
new Set();
assertSingleVersion();
function assert(condition, debugInfo) {
    if (condition) {
        return;
    }
    const debugStr = (() => {
        if (!debugInfo) {
            return '';
        }
        const debugInfoSerialized = typeof debugInfo === 'string' ? debugInfo : '`' + JSON.stringify(debugInfo) + '`';
        return `Debug info (this is for the ${projectInfo_1.projectInfo.projectName} maintainers; you can ignore this): ${debugInfoSerialized}.`;
    })();
    const internalError = (0, createErrorWithCleanStackTrace_1.createErrorWithCleanStackTrace)([
        `${internalErrorPrefix} You stumbled upon a bug in ${projectInfo_1.projectInfo.projectName}'s source code.`,
        `Reach out at ${projectInfo_1.projectInfo.githubRepository}/issues/new and include this error stack (the error stack is usually enough to fix the problem).`,
        'A maintainer will fix the bug (usually under 24 hours).',
        `Do not hesitate to reach out as it makes ${projectInfo_1.projectInfo.projectName} more robust.`,
        debugStr,
    ].join(' '), numberOfStackTraceLinesToRemove);
    throw internalError;
}
exports.assert = assert;
function assertUsage(condition, errorMessage) {
    if (condition) {
        return;
    }
    const whiteSpace = errorMessage.startsWith('[') ? '' : ' ';
    const usageError = (0, createErrorWithCleanStackTrace_1.createErrorWithCleanStackTrace)(`${usageErrorPrefix}${whiteSpace}${errorMessage}`, numberOfStackTraceLinesToRemove);
    throw usageError;
}
exports.assertUsage = assertUsage;
function getProjectError(errorMessage) {
    const pluginError = (0, createErrorWithCleanStackTrace_1.createErrorWithCleanStackTrace)(`${errorPrefix} ${errorMessage}`, numberOfStackTraceLinesToRemove);
    return pluginError;
}
exports.getProjectError = getProjectError;
function assertWarning(condition, errorMessage, { onlyOnce, showStackTrace }) {
    if (condition) {
        return;
    }
    const msg = `${warningPrefix} ${errorMessage}`;
    if (onlyOnce) {
        const key = onlyOnce === true ? msg : onlyOnce;
        if (alreadyLogged.has(key)) {
            return;
        }
        else {
            alreadyLogged.add(key);
        }
    }
    if (showStackTrace) {
        console.warn(new Error(msg));
    }
    else {
        console.warn(msg);
    }
}
exports.assertWarning = assertWarning;
function assertInfo(condition, errorMessage, { onlyOnce }) {
    if (condition) {
        return;
    }
    const msg = `${infoPrefix} ${errorMessage}`;
    if (onlyOnce) {
        const key = msg;
        if (alreadyLogged.has(key)) {
            return;
        }
        else {
            alreadyLogged.add(key);
        }
    }
    console.log(msg);
}
exports.assertInfo = assertInfo;
function assertSingleVersion() {
    versions.add(projectInfo_1.projectInfo.projectVersion);
    if (versions.size >= 2) {
        const versionsStr = Array.from(versions)
            .map((v) => `${projectInfo_1.projectInfo.projectName}@${v}`)
            .join(' and ');
        assertWarning(false, `${versionsStr} loaded which is highly discouraged, see ${picocolors_1.default.underline('https://vike.dev/warning/version-mismatch')}`, { onlyOnce: true });
    }
}
