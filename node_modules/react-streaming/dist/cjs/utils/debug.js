"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isDebugEnabled = exports.createDebugger = void 0;
const isBrowser_1 = require("./isBrowser");
const isCallable_1 = require("./isCallable");
const objectAssign_1 = require("./objectAssign");
const assert_1 = require("./assert");
// Ensure that this is never loaded in the browser. (In order to avoid this file to be included in the client-side bundle.)
// For isomorphic code: use `globalThis.createDebugger()` instead of `import { createDebugger } from './utils'`.
(0, assert_1.assert)(!(0, isBrowser_1.isBrowser)(), 'utils/debug.js loaded in browser');
globalThis.__brillout_debug_createDebugger = createDebugger;
function createDebugger(namespace, optionsGlobal) {
    const debugWithOptions = (options) => {
        return (msg, info) => {
            if (!isDebugEnabled(namespace))
                return;
            if (info !== undefined) {
                msg += strInfo(info, Object.assign(Object.assign({}, optionsGlobal), options));
            }
            console.log('\x1b[1m%s\x1b[0m', namespace, msg);
        };
    };
    const debug = (msg, info) => debugWithOptions({})(msg, info);
    (0, objectAssign_1.objectAssign)(debug, { options: debugWithOptions, isEnabled: isDebugEnabled(namespace) });
    return debug;
}
exports.createDebugger = createDebugger;
function isDebugEnabled(namespace) {
    var _a;
    let DEBUG;
    // - `process` can be undefined in edge workers
    // - We want bundlers to be able to statically replace `process.env.*`
    try {
        DEBUG = process.env.DEBUG;
    }
    catch (_b) { }
    return (_a = DEBUG === null || DEBUG === void 0 ? void 0 : DEBUG.includes(namespace)) !== null && _a !== void 0 ? _a : false;
}
exports.isDebugEnabled = isDebugEnabled;
function strInfo(info, options) {
    var _a, _b;
    if (info === undefined) {
        return undefined;
    }
    let str = '\n';
    if (typeof info === 'string') {
        str += info;
    }
    else if (Array.isArray(info)) {
        if (info.length === 0) {
            str += (_b = (_a = options.serialization) === null || _a === void 0 ? void 0 : _a.emptyArray) !== null && _b !== void 0 ? _b : '[]';
        }
        else {
            str += info.map(strUnknown).join('\n');
        }
    }
    else {
        str += strUnknown(info);
    }
    str = pad(str);
    return str;
}
function pad(str) {
    const PADDING = '     ';
    const terminalWidth = getTerminalWidth();
    const lines = [];
    str.split('\n').forEach((line) => {
        if (!terminalWidth) {
            lines.push(line);
        }
        else {
            chunk(line, terminalWidth - PADDING.length).forEach((chunk) => {
                lines.push(chunk);
            });
        }
    });
    return lines.join('\n' + PADDING);
}
function chunk(str, size) {
    if (str.length <= size) {
        return [str];
    }
    const chunks = str.match(new RegExp('.{1,' + size + '}', 'g'));
    (0, assert_1.assert)(chunks);
    return chunks;
}
function strUnknown(thing) {
    return typeof thing === 'string' ? thing : strObj(thing);
}
function strObj(obj, newLines = false) {
    return JSON.stringify(obj, replaceFunctionSerializer, newLines ? 2 : undefined);
}
function replaceFunctionSerializer(_key, value) {
    if ((0, isCallable_1.isCallable)(value)) {
        return value.toString().split(/\s+/).join(' ');
    }
    return value;
}
function getTerminalWidth() {
    // https://stackoverflow.com/questions/30335637/get-width-of-terminal-in-node-js/30335724#30335724
    return ((typeof process !== 'undefined' && typeof process.stdout !== 'undefined' && process.stdout.columns) || undefined);
}
