export { createPipeWrapper };
import { createDebugger } from '../utils';
import { orchestrateChunks } from './orchestrateChunks';
const debug = createDebugger('react-streaming:createPipeWrapper');
import { Writable } from 'stream';
async function createPipeWrapper(pipeFromReact, onReactBug, clearTimeouts, doNotClosePromise) {
    const { pipeForUser, streamEnd } = createPipeForUser();
    const streamOperations = {
        operations: null,
    };
    const { injectToStream, onReactWrite, onBeforeEnd, hasStreamEnded } = orchestrateChunks(streamOperations, doNotClosePromise);
    return { pipeForUser, streamEnd, injectToStream, hasStreamEnded };
    function createPipeForUser() {
        debug('createPipeForUser()');
        let onEnded;
        const streamEnd = new Promise((r) => {
            onEnded = () => r();
        });
        const pipeForUser = (writableFromUser) => {
            const writableForReact = new Writable({
                write(chunk, _encoding, callback) {
                    debug('write');
                    if (!writableFromUser.destroyed) {
                        // We cannot await inside write() as we cannot make write() async because of Rule 1: https://github.com/brillout/react-streaming/tree/main/src#rule-1
                        onReactWrite(chunk);
                    }
                    else {
                        // - E.g. when the server closes the connection.
                        // - Destroying twice is fine: https://github.com/brillout/react-streaming/pull/21#issuecomment-1554517163
                        writableForReact.destroy();
                    }
                    callback();
                },
                async final(callback) {
                    debug('final');
                    clearTimeouts();
                    await onBeforeEnd();
                    writableFromUser.end();
                    onEnded();
                    callback();
                },
                destroy(err) {
                    debug(`destroy (\`!!err === ${!!err}\`)`);
                    clearTimeouts();
                    // Upon React internal errors (i.e. React bugs), React destroys the stream.
                    if (err)
                        onReactBug(err);
                    writableFromUser.destroy(err !== null && err !== void 0 ? err : undefined);
                    onEnded();
                },
            });
            const flush = () => {
                if (typeof writableFromUser.flush === 'function') {
                    ;
                    writableFromUser.flush();
                    debug('stream flushed (Node.js Writable)');
                }
            };
            streamOperations.operations = {
                flush,
                writeChunk(chunk) {
                    writableFromUser.write(chunk);
                },
            };
            writableForReact.flush = flush;
            pipeFromReact(writableForReact);
        };
        return { pipeForUser, streamEnd };
    }
}
